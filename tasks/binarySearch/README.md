# Бинарный поиск

Бинарный поиск — это алгоритм, который используется для поиска элемента в отсортированном массиве. Основная идея
заключается в том, чтобы на каждом шаге уменьшать область поиска вдвое, сужая ее с одной стороны в зависимости от того,
как элемент соотносится с текущим средним значением. Это позволяет значительно ускорить процесс поиска, сокращая
количество проверок с O(n) до O(log n).

Алгоритм бинарного поиска

Бинарный поиск работает следующим образом:

1. Устанавливаем два указателя: left (левая граница) и right (правая граница) на начало и конец массива.
2. Находим средний элемент массива с помощью формулы: mid = left + (right - left) / 2.
3. Сравниваем средний элемент с искомым:

- Если он равен искомому значению, то нашли элемент.
- Если элемент меньше, продолжаем поиск в правой половине (обновляем left = mid + 1).
- Если элемент больше, продолжаем поиск в левой половине (обновляем right = mid - 1).

4. Повторяем процесс, пока указатели не пересекутся, что будет означать, что элемент не найден.

### 1. First Bad Version

Задача: На вход подается целое число n, представляющее количество версий ПО. Версии отсортированы, и среди них есть как
хорошие, так и плохие. Нужно найти первую плохую версию.

Объяснение:

1. Начинаем с диапазона от 1 до n.
2. Вычисляем среднее значение mid.
3. Если версия на mid плохая, сужаем поиск, ищем в левой части.
4. Если версия хорошая, сужаем поиск вправо.
5. Как только указатели встретятся, мы получим первую плохую версию.

### 2. Valid Perfect Square

Задача: Проверить, является ли число совершенным квадратом.

Объяснение:

1. Мы начинаем с диапазона от 1 до num.
2. Находим среднее значение mid.
3. Если квадрат mid равен числу num, значит это совершенный квадрат.
4. Если квадрат меньше, то нужно увеличивать mid, иначе уменьшаем диапазон.
5. Если мы не нашли число, возвращаем false.

### 3. Search Insert Position

Задача: Найти позицию, в которую можно вставить элемент в отсортированный массив.

Объяснение:

1. Мы ищем место для вставки элемента в отсортированном массиве.
2. Если элемент найден, возвращаем его индекс.
3. Если не найден, возвращаем индекс, куда его нужно вставить.
4. Бинарный поиск помогает быстро найти место, где вставить элемент, не проходя весь массив.

### 4. Sqrt(x)

Задача: Найти целочисленный квадратный корень числа x.

Объяснение:

1. Мы ищем целое число mid, квадрат которого равен числу x.
2. Если находим такой mid, возвращаем его.
3. Если квадрат mid меньше x, сдвигаем левую границу, иначе правую.
4. Когда область поиска сжата, возвращаем наибольший mid, квадрат которого меньше или равен x.

### 5. Search in Rotated Sorted Array

Задача: Найти элемент в отсортированном и вращенном массиве.

Объяснение:

1. Мы находим, в какой части массива мы находимся: отсортирована ли левая или правая половина.
2. Если левая половина отсортирована, проверяем, не попадает ли целевой элемент в этот диапазон.
3. Если правая половина отсортирована, проверяем её.

### 6. Peak Index in a Mountain Array

Задача: Найти индекс вершины в массиве, где элементы сначала возрастают, а затем уменьшаются.

Объяснение:

1. Мы ищем пик массива, где элементы сначала возрастают, а потом уменьшаются.
2. Сравниваем элементы по обеим сторонам от середины.
3. Если средний элемент меньше следующего, идем вправо, иначе — влево.
[Асимптотический анализ](#Асимптотический-анализ)

[Бинарный поиск](#Бинарный-поиск)

## Асимптотический анализ

Асимптотический анализ — это метод, используемый для оценки эффективности алгоритмов, в частности, их сложности при
очень больших входных данных. Он позволяет определить, как изменяется время работы алгоритма или используемая память по
мере увеличения размера входных данных. В асимптотическом анализе выделяют несколько типов оценок: верхнюю, нижнюю и
усредненную. Рассмотрим каждую из них более подробно.

## Типы оценок

### 1. Верхняя оценка (Big-O)

Верхняя оценка (Big-O) описывает максимальное возможное время или память, которое алгоритм может занять при увеличении
размера входных данных. Это гарантирует, что алгоритм не будет работать хуже, чем указано в этой оценке, даже в самом
неблагоприятном случае.

Пример:

Для алгоритма сортировки слиянием, время работы которого составляет, его верхняя оценка будет.
Это означает, что алгоритм не будет работать медленнее, чем, независимо от конкретного входа.

### 2. Усредненная оценка

Усредненная оценка анализирует производительность алгоритма в среднем, принимая во внимание вероятностное распределение
входных данных. Это означает, что усредненная оценка показывает время или пространство, которое потребуется для
обработки «среднего» случая, а не самого худшего.


Пример:

Алгоритм быстрой сортировки в среднем работает за время. Однако, если вход отсортирован или почти отсортирован, то его
производительность будет намного выше, чем в худшем случае. Средняя оценка будет учитывать эти вероятности.

### 3. Нижняя оценка (Omega)

Нижняя оценка (Omega) показывает минимальное время, которое алгоритм может потратить на решение задачи в лучшем случае.
Это гарантирует, что алгоритм не будет работать быстрее, чем указано в нижней оценке, даже в лучшем случае.

Пример:

Для алгоритма сортировки слиянием нижняя оценка будет, потому что алгоритм не может быть быстрее, чем это время, даже в
лучшем случае.

Основные отличия между оценками:

Big-O (верхняя оценка): Гарантирует максимальное время работы в худшем случае, определяет, что алгоритм не будет
работать хуже, чем указано.
Omega (нижняя оценка): Гарантирует минимальное время работы в лучшем случае, не будет работать быстрее, чем указано.
Усредненная оценка: Показывает среднюю производительность алгоритма, учитывая вероятностное распределение входных
данных.

Пример в контексте сортировки:

Верхняя оценка (Big-O): Для быстрой сортировки в худшем случае (например, если данные отсортированы в обратном порядке).
Усредненная оценка: Для быстрой сортировки среднее время работы составляет.
Нижняя оценка (Omega): Для быстрой сортировки в лучшем случае (например, если данные уже отсортированы).

Таким образом, асимптотический анализ помогает понять, как алгоритм будет себя вести в различных условиях, и выбрать
оптимальный алгоритм для задачи.

### Сравнение оценок

| Оценка      | Что описывает                             | Пример                                     |
|-------------|-------------------------------------------|--------------------------------------------|
| **Big-O**   | Максимальное время работы (худший случай) | Быстрая сортировка: \( O(n^2) \)           |
| **Средняя** | Среднее время работы                      | Быстрая сортировка: \( O(n \log n) \)      |
| **Omega**   | Минимальное время работы (лучший случай)  | Быстрая сортировка: \( \Omega(n \log n) \) |

## Пример для сортировки

- **Big-O**: Быстрая сортировка в худшем случае работает за \( O(n^2) \), если данные уже отсортированы в обратном
  порядке.
- **Средняя оценка**: Для случайных входных данных время работы составляет \( O(n \log n) \).
- **Omega**: В лучшем случае (уже отсортированные данные) время работы составляет \( \Omega(n \log n) \).

## Заключение

Асимптотический анализ помогает выбрать оптимальный алгоритм, анализируя его поведение в различных условиях: худший,
средний и лучший случаи. Это инструмент для принятия решений при проектировании эффективных программ.

# Базовые структуры данных

Базовые структуры данных — это фундаментальные типы данных, которые используются для организации и хранения информации
таким образом, чтобы она могла быть эффективно извлечена, изменена и обработана. Каждая структура данных имеет свои
особенности, преимущества и недостатки в зависимости от ситуации. Рассмотрим подробно каждую из них:

1. Массивы (Arrays)

Массив — это структура данных, которая хранит элементы одинакового типа в последовательной области памяти. Элементы
массива имеют фиксированный размер, и доступ к ним осуществляется по индексу. Индексация начинается с нуля (в
большинстве языков программирования).

Достоинства:
- Доступ к элементам массива за (постоянное время) по индексу.
- Простой и эффективный способ хранения данных.

Недостатки:
- Размер массива фиксирован и не может быть изменён после его создания (в статических массивах).
- Вставка или удаление элементов в середину массива требует сдвига элементов, что занимает времени. 

Пример:

Массив чисел [5, 3, 8, 1, 4] в памяти может выглядеть как последовательность значений, где каждый элемент доступен по
индексу.

2. Списки (Linked Lists)

Связный список — это линейная структура данных, в которой элементы (узлы) хранятся не в последовательной области памяти,
а каждый узел содержит ссылку (или указатель) на следующий узел.

- Односвязный список (Singly Linked List): Каждый узел содержит данные и указатель на следующий узел.
- Двусвязный список (Doubly Linked List): Каждый узел содержит данные, указатель на следующий и на предыдущий узел.

Достоинства:
- Легко добавлять и удалять элементы, особенно в начале или в середине списка.
- Размер списка не фиксирован и может динамически изменяться.

Недостатки:
- Доступ к элементам происходит по последовательному поиску.
- Дополнительная память требуется для хранения ссылок на соседние узлы.

Пример:

Односвязный список: A -> B -> C -> D, где каждый узел содержит значение и указатель на следующий узел.

3. Стек (Stack)

Стек — это структура данных, работающая по принципу “LIFO” (Last In, First Out — последний пришёл, первый ушёл). Это
означает, что элементы добавляются в конец стека и удаляются также с конца.

Операции:
- Push: Добавление элемента на вершину стека.
- Pop: Удаление элемента с вершины стека.
- Peek: Просмотр элемента на вершине стека без его удаления.

Достоинства:
- Простота реализации: Легко реализуется с использованием массива или связного списка.
- Быстрая работа: Операции добавления и удаления (push/pop) выполняются за O(1).
- Эффективное управление памятью: Использует память только под хранимые элементы.
- Последовательность доступа: Логика LIFO (последний вошел — первый вышел) упрощает управление данными.
- Удобство в рекурсивных задачах: Часто используется для обработки рекурсий и хранения промежуточных данных.
- Применимость: Полезен в алгоритмах обратной польской записи, проверке скобок, реализации вызовов функций (стек
вызовов).

Недостатки:
- Ограниченный доступ: Можно работать только с верхним элементом (нет произвольного доступа).
- Фиксированный размер (для массива): В статической реализации стек ограничен размером, задаваемым заранее.
- Риск переполнения: В случае недостатка памяти при добавлении новых элементов.
- Неэффективность удаления всех элементов: Очистка требует последовательного извлечения каждого элемента.
- Однонаправленная структура: Не подходит для задач, требующих доступа к произвольным данным.

Пример:

Стек из чисел: [5, 3, 8], где 8 — это верхний элемент.

4. Очередь (Queue) / Двусторонняя очередь (Deque)

Очередь — это структура данных, работающая по принципу “FIFO” (First In, First Out — первый пришёл, первый ушёл).
Элементы добавляются в конец очереди и удаляются из начала.


Операции:
- Enqueue: Добавление элемента в конец очереди.
- Dequeue: Удаление элемента из начала очереди.
- Front: Просмотр элемента в начале очереди.
 
Достоинства:
- Упрощенная структура: Легко реализуется для задач FIFO (первый вошел — первый вышел).
- Эффективность: Добавление и удаление элементов выполняются за O(1).
- Очередность обработки: Подходит для задач, требующих последовательного выполнения (потоки, запросы, обработка задач).
- Широкое применение: Используется в системах планирования, симуляциях, сетевых приложениях.

Недостатки:
- Ограниченный доступ: Работа возможна только с началом и концом, нет произвольного доступа к элементам.
- Риск переполнения: В случае статической реализации (массив) размер ограничен.
- Накладные расходы: В кольцевой реализации требуется управление указателями.
- Неэффективность динамических изменений: Увеличение размера (в массивной реализации) может быть затратным.

Двусторонняя очередь (Deque) — это расширение очереди, которое позволяет добавлять и удалять элементы с обоих концов.

Операции:
- AddFront: Добавление элемента в начало.
- AddBack: Добавление элемента в конец.
- RemoveFront: Удаление элемента с начала.
- RemoveBack: Удаление элемента с конца.

Достоинства:
- Гибкость: Поддерживает добавление и удаление элементов с обеих сторон.
- Универсальность: Может работать как стек или очередь.
- Эффективность: Все операции выполняются за O(1) (в большинстве реализаций).
- Применимость: Идеальна для задач с динамическим управлением элементами, например, в алгоритмах поиска или кэширования (LRU).

Недостатки:
- Сложность реализации: Требуется больше ресурсов для управления двумя сторонами.
- Увеличение памяти: Дополнительные указатели или буферная память.
- Неоптимальность: Не подходит для задач, требующих произвольного доступа к элементам.

5. Хэш-таблицы (Hash Tables)

Хэш-таблица — это структура данных, которая использует хэш-функцию для преобразования ключа в индекс, где хранится
соответствующее значение.

Операции:
- Insert: Вставка пары ключ-значение.
- Search: Поиск значения по ключу.
- Delete: Удаление пары ключ-значение.

Достоинства:
- Быстрый доступ: Поиск, вставка и удаление элементов выполняются в среднем за O(1).
- Гибкость ключей: Поддержка ключей различных типов (строки, числа и др.).
- Эффективное управление данными: Идеально подходит для хранения ассоциативных массивов и пар “ключ-значение”.
- Универсальность: Применяются в базах данных, кэшировании, хэшировании паролей и других задачах.
- Масштабируемость: Легко адаптируется под большие объемы данных с использованием хэш-функций.

Недостатки:
- Коллизии: Возможны конфликты ключей, требующие дополнительной обработки (цепочки, открытая адресация).
- Зависимость от хэш-функции: Плохая хэш-функция снижает производительность.
- Неупорядоченность: Данные не хранятся в определенном порядке.
- Высокое потребление памяти: Требуется больше памяти из-за резервирования под массив и обработки коллизий.
- Сложность при масштабировании: Рехэширование при увеличении размера может быть затратным.
- Ограничения ключей: Требуется уникальность ключей, и они должны быть хэшируемыми.

6. Деревья (Trees)

Дерево — это иерархическая структура данных, состоящая из узлов, где каждый узел может иметь несколько дочерних узлов.
Корень дерева — это начальный узел, от которого отходят все остальные.

Типы деревьев:
- Двоичное дерево (Binary Tree)
Каждая вершина имеет максимум два потомка (левый и правый).
- Сбалансированное дерево (Balanced Tree)
Высота всех поддеревьев различается не более чем на 1 (например, AVL-дерево, Красно-черное дерево). 
- Двоичное дерево поиска (Binary Search Tree)
Левый потомок меньше корня, правый — больше, используется для быстрого поиска.
- Полное двоичное дерево (Complete Binary Tree)
Все уровни, кроме последнего, полностью заполнены, узлы последнего уровня выровнены слева.
- Полное дерево (Full Binary Tree)
У каждого узла либо 0, либо 2 потомка.
- N-арное дерево (N-ary Tree)
Каждый узел может иметь до N потомков. 
- Красно-черное дерево (Red-Black Tree)
Сбалансированное дерево, где узлы окрашены в красный или черный для обеспечения равновесия. 
- AVL-дерево
Двоичное дерево поиска с автоматическим балансом высоты после каждой операции. 
- Куча (Heap)
Специальное дерево, где каждый родитель больше (макс-куча) или меньше (мин-куча) своих потомков. 
- Б-дерево (B-Tree)
Самобалансирующееся дерево для хранения и упорядоченного поиска данных, часто используется в базах данных. 
- Б+-дерево (B+ Tree)
Модификация B-дерева с улучшением для диапазонных запросов. 
- Trie (Префиксное дерево)
Для хранения строк, ключи узлов представляют собой последовательности символов. 
- Декартово дерево (Treap)
Комбинация двоичного дерева поиска и кучи, с балансировкой по случайному приоритету. 
- Суффиксное дерево (Suffix Tree)
Специализированное дерево для строк, применяется в задачах поиска подстрок. 
- Меркатное дерево (Splay Tree)
Самоорганизующееся дерево, перемещает часто используемые элементы ближе к корню.

Достоинства:
- Иерархическая структура: Удобны для представления данных с природной иерархией (файловая система, базы данных).
- Эффективность поиска: Быстрый доступ, вставка и удаление (в сбалансированных деревьях) — O(log n).
- Гибкость: Поддерживают разные виды операций, включая обход (прямой, обратный, симметричный).
- Упорядоченность: В деревьях поиска элементы хранятся в отсортированном виде.
- Широкое применение: Используются в компиляторах, парсерах, сетевых маршрутах, искусственном интеллекте.

Недостатки:
- Сложность реализации: Требуется больше усилий для написания и отладки (особенно для сбалансированных деревьев).
- Потребление памяти: Хранение указателей для связей между узлами.
- Неравномерность: Несбалансированные деревья ухудшают производительность (до O(n) в худшем случае).
- Трудности модификации: Вставка или удаление может нарушить баланс дерева, требуя дополнительных операций.

7. Графы (Graphs)

Граф — это структура данных, состоящая из узлов (вершин) и рёбер, которые соединяют эти узлы.

Типы графов:
- Ориентированные графы: Рёбра имеют направление.
- Неориентированные графы: Рёбра не имеют направления.
- Взвешенные графы: Рёбра имеют веса.

Операции:
- Поиск в глубину (DFS).
- Поиск в ширину (BFS).
- Алгоритмы для нахождения кратчайшего пути (например, алгоритм Дейкстры).

Достоинства:
- Гибкость модели: Представляют любые виды связей и отношений (социальные сети, маршруты, зависимости).
- Широкое применение: Используются в алгоритмах маршрутизации, сетевых вычислениях, анализе данных.
- Разнообразие типов: Позволяют моделировать сложные структуры (ориентированные, взвешенные, деревья и др.).
- Эффективность обработки: Алгоритмы поиска путей (DFS, BFS), кратчайшего пути (Dijkstra, A*) оптимальны для решения задач.
- Визуализация связей: Удобны для анализа взаимосвязей между объектами.
- Масштабируемость: Подходят для больших систем с динамическими изменениями (добавление/удаление узлов и ребер).

Недостатки:
- Сложность реализации: Графы могут быть сложными для реализации и требуют эффективных структур данных (например, матрица смежности или список смежности).
- Потребление памяти: Для хранения больших графов (особенно взвешенных или с множественными рёбрами) требуется много памяти. Матрица смежности может занимать O(n²) памяти, что может быть неэффективно для разреженных графов.
- Сложность обработки: Алгоритмы поиска путей или обхода графов (например, поиск в глубину, в ширину) могут быть сложными и ресурсоемкими, особенно в графах с большим количеством вершин и рёбер.
- Отсутствие порядка: В графах часто нет естественного порядка (в отличие от деревьев), что может осложнить их анализ или визуализацию.
- Циклы: В графах с циклами могут возникать проблемы с бесконечными циклами при поиске путей или обходах, если алгоритмы не правильно настроены для их обработки.
- Низкая производительность для плотных графов: Если граф плотный (много рёбер между вершинами), алгоритмы, использующие матрицу смежности, могут быть медленными и ресурсоемкими.
- Ограничения на типы данных: В некоторых случаях может быть сложно правильно подобрать типы данных для представления графа (например, для работы с графами, где рёбра и вершины могут иметь дополнительные атрибуты).


8. Бинарная куча (Binary Heap)

Бинарная куча — это специализированное бинарное дерево, используемое для реализации очереди с приоритетом. Она может
быть макс-кучей (где значение родителя больше или равно значениям его детей) или мин-кучей (где значение родителя меньше
или равно значениям его детей).

Операции:
- Insert: Добавление элемента в кучу.
- Extract-Min/Max: Извлечение минимального/максимального элемента.

Достоинства:
- Быстрое извлечение минимального или максимального элемента:
Операции вставки и извлечения (pop) выполняются за время O(log n), что делает кучу очень эффективной для реализации приоритетных очередей.
- Гарантированная производительность:
Все операции, такие как вставка и удаление, имеют предсказуемое время выполнения (O(log n)), что делает кучу эффективной для динамических наборов данных.
- Простота реализации:
Бинарную кучу легко реализовать с использованием массива или списка (при этом можно эффективно использовать индексы для представления дерева).
- Хорошее использование памяти:
Куча требует только O(n) памяти, так как она обычно реализуется как массив без необходимости хранения указателей, как в деревьях.
- Использование в алгоритмах:
Часто используется в таких алгоритмах, как сортировка кучей (heap sort), поиск минимального/максимального элемента (например, для приоритетных очередей) и в алгоритмах для поиска кратчайшего пути (например, алгоритм Дейкстры).

Недостатки:
- Отсутствие произвольного доступа:
	В бинарной куче нет возможности произвольно получить доступ к элементам (например, нельзя быстро найти произвольный элемент, если не извлекаешь его по порядку). Для этого нужно пройти по дереву, что требует O(n) времени.
- Неустойчивость при изменении приоритетов:
	В случае, если приоритет элементов в куче меняется, кучу необходимо перестроить (провести операцию снижения или увеличения приоритета). Это может занять O(log n) времени.
- Проблемы с балансировкой:
	Хотя куча и является сбалансированным деревом, она не всегда подходит для всех типов данных, например, когда требуется полное упорядочивание элементов. В таких случаях другие структуры данных, такие как сбалансированные деревья поиска (например, AVL или красно-черные деревья), могут быть более подходящими.
- Неупорядоченность внутри самой кучи:
	Хотя на верхнем уровне (в корне) элемент будет минимальным или максимальным (в зависимости от типа кучи), элементы на других уровнях не будут упорядочены, что делает кучу менее удобной для некоторых типов операций, таких как поиск или обновление всех элементов.
- Неэффективность для некоторых типов запросов:
	Если задача требует частого поиска минимального или максимального элемента среди всех элементов, то куча не будет эффективной, так как она не поддерживает такую операцию. Для этого лучше использовать другие структуры данных (например, деревья поиска).
Эти структуры данных являются основой для более сложных алгоритмов и оптимизаций в компьютерных науках. Выбор подходящей
структуры данных зависит от задачи и желаемой эффективности операций.